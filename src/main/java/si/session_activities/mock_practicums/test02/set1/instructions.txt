0. You are required to write a class JavaDoc with your name at the top of each
   file that you create. You are not required to write any other comments 
   unless you feel that it is useful to do so. You are expected to follow best
   practices with respect to naming conventions and encapsulation. 

   You should verify that you are able to run the provided "TotalerGUI" 
   application. You should be able to run the class using the VSCode play 
   button. Failing that, you can try the following command from the terminal:

     mvn clean compile javafx:run
   
   Raise your hand if the application does not run.


1. (20 Points) Examine the EyeColor, Month, and Fleeb classes that have been 
   provided to you in the "fleebs" package. Notice that Fleebs do not have a 
   natural order. Modify the Fleeb class to define a natural order that 
   arranges a group of Fleebs in order based on the intensity of their eye 
   colors (from MOST intense to LEAST intense). 

   Use the provided FleebTest JUnit test to test your solution by uncommenting 
   the appropriate test and running it. You will need to add some imports to 
   the test.


2. (20 Points) Sometimes it is preferable to arrange Fleebs in order by their 
   birth month. If two fleebs have the same birth month, then they are sorted
   by day. 

   For example, a Fleeb born in Fleebtober (the 6th month of the year) would 
   be sorted after a Fleeb born in Smarch (the first month of the year). Two 
   Fleebs that were both born in Septembruary would be arranged in order of 
   the day on which they were born.

   Implement a helper class that can be used to arrange Fleebs in this way. 
   You will need to make further modifications to the Fleeb class to implement 
   the helper class.

   Use the provided FleebTest JUnit test to test your solution by uncommenting
   the appropriate test and running it. You will need to add some imports to 
   the test. In order for the provided test to pass, your helper class MUST be
   named "BirthdaySorter".


3. (20 Points) A Deque (pronounced like "deck") is a double-ended queue - 
   values can be enqueued and dequeued from both ends of the queue. 

   Operation                   Deque Configuration 

   d.enqueueFront(111)         {111}, size=1
   d.enqueueBack(222)          {111, 222}, size=2
   d.enqueueFront(333)         {333, 111, 222}, size=3
   d.enqueueBack(444)          {333, 111, 222, 444}, size=4
   d.dequeueBack()             {333, 111, 222}, size=3
   d.dequeueFront()            {111, 222}, size=2
   
   Using the UML provided in the "deque" package as a guide, create an abstract
   data type (ADT) to represent the deque data structure. Include a default 
   implementation of the iterator() method that throws an 
   UnsupportedOperationException.
   
   Note: for this problem, you only need to create the Deque ADT. You will 
   implement the data structure in the next problem.


4. (20 Points) Create a new Java class named "MyDeque" and use it to implement
   the Deque ADT. You may use the data structure of your choice, including 
   those provided to you in this repository and the JCF implementations of the 
   data structures introduced in units 5 and 6 (excluding Java's Deque 
   implementation). 
   
   When used with a for-each loop, your Deque implementations hould iterate 
   through the elements front-to-back. You DO NOT need to write your own 
   iterator to solve this problem: you may use one of the iterators provided to
   you in this repository or the iterator provided by the data structure that 
   you chose to implement your Deque.

   For full credit on this problem, all of the basic operations of your Deque
   implementation must run in constant time: O(C). 

   You may test your Deque using the provided JUnit test. It is strongly 
   recommended that you uncomment the tests one at a time to verify that your
   implementation is functioning properly before running additional tests. Your
   solution will be tested using a similar unit test with additional tests.


5. (20 Points) Take a moment to examine the files provided to you in the
   "totaler.model" package. DO NOT modify the code in these classes.

   TotalObserver - an interface that may be implemented by a class that may
   register to be notified whenever a total changes (see below). 

   Totaler - a class that keeps track of a running total. Values may be added
   to or subtracted from the total using the corresponding methods. Note that
   the parameters are STRINGS (not a numeric type). If the running total 
   changes, the observer is notified.

   For this activity, you will complete the the provided TotalerGUI JavaFX GUI 
   application so that it provides at least the following functionality:

   - A JavaFX control that displays the current total. You MUST implement the 
     provided TotalObserver interface and use it to update the total displayed
     if/when it changes in the Totaler.
   - A JavaFX control that provides the user with a means to enter a numeric 
     value. You DO NOT need to validate that the user has entered a valid 
     value.
   - A JavaFX control that the user may press to add the amount entered to the
     current total.
   - A JavaFX control that the user may press to subtract the amount entered
     from the current total.

   Your application need only provide the basic functionality described above.
   You DO NOT need to customize the JavaFX controls in your application 
   (though you may if you wish to do so).

   See the provided example image for one possible GUI configuration. You DO
   NOT need to match this image. 